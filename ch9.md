# 第9章 一致性与共识

[TOC]

# 构建容错式分布式系统的相关算法和协议

分布式系统可能发生的故障：网络数据包可能会丢失、顺序紊乱、重复发送或延迟、时钟也有一定偏差，节点可能发生暂停（例如GC）甚至随时崩溃。

# 分布式系统可提供的若干保证和抽象机制

一致性保证

多种不同的一致性模型

分布式一致性主要是针对延迟和故障等问题来协调副本之间的状态。

事务隔离主要是为了处理并发执行事务时的各种临界条件。

## 可线性化（最强的一致性模型、强一致性）

### 什么是可线性化

基本思想是让一个系统看起来好像只有一个数据副本，且所有的操作都是原子的。有了这个保证，应用程序就不需要关心系统内部的多个副本。

在一个可线性化系统中，一旦某个客户端成功提交写请求，所以客户端的读请求一定都能看到刚刚写入的值。

### 如何达到线性化

**线性化存储服务是所有这些协调服务的基础。**

### 实现线性化系统

共识协议通常内置一些措施防止脑裂和过期的副本。共识算法可以安全的实现线性化存储，这些系统包括ZooKeeper和etcd等。

## 顺序保证

全序关系

全序 vs 偏序

因果一致性可以认为是，不会由于网络延迟而显著影响性能，又能对网络故障提供容错的最强的一致性模型。

版本向量技术



### 全序关系广播

主从复制首先确定一个节点为主节点，然后在主节点上顺序执行操作。接下来的挑战在于，如何扩展系统的吞吐量使之突破单一主节点的限制，以及如何处理主节点失效时的故障切换。在分布式系统研究文献中，这些问题被称为全序关系广播或者原子广播。

全序关系广播通常指节点之间交换消息的某种协议。它要求满足两个基本属性：

- 可靠发送
- 严格有序

像ZK和etcd这样的共识服务实际上就实现了全序关系广播。

# 分布式事务与共识

## 共识问题

分布式计算中最基本最重要的问题，目标是让几个节点就某件事达成一致。

一个或多个节点可以提议某些值，由共识算法来决定最终值。

## 共识的应用场景

- 主节点选举
- 原子事务提交

​		对于支持跨节点或者跨分区事务的数据库，某事务可能在一些节点上执行成功，但在其它节点上发生了失败。为了维护事务的原子性，所有节点必须对事务的结果达成一致。这个共识的例子被称为原子提交问题。

## 原子提交问题

如果一部分节点提交了事务，而其它节点却放弃了事务，节点之间就会变得不一致。而且某个节点一旦提交了事务，即使事后发现其它节点发生中止，它也无法再撤销已提交的事务。正因如此，**如果有部分节点提交了事务，则所有节点也比较跟着提交事务。**

事务提交不可撤销，不能事后在改变主意（提交之后再追溯去中止）。这些规则背后的深层次原因是，一旦数据提交，就被其它事务可见，继而其它客户端会基于此做出响应的决策。这个原则构成了读-提交隔离级别的基础。如果允许事务在提交后还能中止，会违背之后所有读-提交的事务，进而被迫产生级联式的追溯和撤销。

当然已提交的事务的效果可以被之后一笔新的事务来抵消掉，即补偿性事务。不过从数据库的角度看，前后两个事务完全独立。类似这种跨事务的正确性需要由应用层来负责。

## 共识的局限性

- 共识体系需要严格的多数节点才能运行
- 多数 共识算法假定一组固定参与投票的节点集，这意味着不能动态添加或删除节点
- 共识系统通常依靠超时来检测节点失效，对网络问题特别敏感。网络延迟高度不确定的环境中，可能产品频繁选举。

## 成员与协调服务





## 共识算法的性质

共识算法必须满足以下性质：

- 协商一致性（Uniform agreement）

  所有的节点都接受相同的决议

- 诚实性（Integrity）

​		所有节点不能反悔，即对一项提议不能有两次决定

- 合法性（Validity）

​		如果决定了值v，则v一定是由某个节点所提议的

- 可终止性（Termination）

​		节点如果不崩溃则最终一定可以达成协议

## 常见的共识算法

著名的容错式共识算法包括：VSR、Paxos、Raft和Zab。这些算法存在诸多相似之处，但又不完全相同。

VSR、Raft和Zab都直接采取了全序关系广播。

### 2PC两阶段提交算法

tow-phase commit，2PC是一种在多个节点之间实现事务原子性提交的算法，用来确保所有的节点要么全部提交，要么全部中止。它是分布式数据库中的经典算法之一。

![2PC](/Users/shihujiang/Downloads/2PC.jpeg)

#### 2PC提交的特点

- 引入了新的组件-协调者

#### 2PC可能遇到的问题

- 协调者故障
- 事务参与者崩溃

#### 2PC的缺点

2PC也称为阻塞式原子提交协议，因为2PC可能在等待协调者恢复时卡住。

### 三阶段提交

3PC假定一个有界的网络延迟和节点在规定时间内响应。非阻塞原子提交依赖一个完美的故障检测器，即有一个非常可靠的机制可以判断出节点是否已经崩崩溃。在无限延迟的网络环境中，超时机制并不是可靠的故障检测器，因为即使节点正常，请求也可能由于网络问题而最终超时。正是由于这样的原因，尽管大家意见意识到协调者潜在的问题，但还在普遍使用2PC。

# 实践中的分布式事务

- 数据库内部的分布式事务

- 异构分布式事务

### XA（eXtended Architecture）交易

XA是异构环境下实施两阶段提交的一个工业标准。于1991推出并得到广泛推广。许多传统关系数据库和消息队列都支持XA。

XA并不是一个网络协议，而是一个与事务协调者进行通信的C API。当然，他也支持其它语言的API绑定。例如Java EE中，XA事务是由Java事务API（JTA）来实现，JTA可以支持非常多JDBC（Java Database Connectivity）驱动和消息队列驱动（JMS）。

XA假定应用程序通过网络或客户端的库函数与参与者（包括数据库、消息服务）节点通信。如果驱动程序支持XA，意味着应用可以调用XA API来确定操作是否是异构分布式事务的一部分。如果是，则发生必要的信息给数据库服务器。

### 停顿时仍持有锁

在两阶段提交中，如果协调者崩溃且需要20分钟才能重启恢复，那么这些对象将被锁定20分钟；

数据加锁时，其它事务就无法执行修改。

### 从协调者故障中恢复

理论上，如果协调者崩溃之后重新启动，它应该可以从日志中恢复哪些停顿的事务，然而在实践中，孤立的不确定事务确实会发生。

即使重启那些处于停顿状态的数据库节点也无法解决这个问题，这是由于2PC的正确实现要求即使发生重启，也要继续保持重启之前事务的加锁。

唯一的解决办法是让管理员手动决定究竟是执行提交还是回滚。管理员必须仔细检查每个有问题的参与者，确定是否有节点已经事实完成了提交（或中止），然后要将相同的结果一一应用于所有的参与者上。这种方案需要大量的手工操作，而且很可能处在关键生产环境的中断间隙，背负着巨大的压力和时间限制。

许多XA的实现都支持某种紧急措施称之为启发式决策：这样参与者节点可以在紧急情况下单方面做出决定，放弃或者继续那些停顿的事务，而不需要等到协调者发出指令。需要说明的是，这里的启发式其实是可能破坏原子性的委婉说法，它的确违背了2PC所做出的承诺。因此，这种启发式决策只是为了应急，不能作为常规手段来使用。

### 分布式事务的限制

XA事务解决了参与者之间如何达成一致这样一个非常现实而重要的问题。

- 如果协调者在单节点上运行，那么它就是整个系统的单点故障。

- 许多服务端程序都倾向于无状态，而所有的持久状态都保存在数据库中。但是，当协调者就是应用程序的一部分时，部署方式就发生了根本的变化，协调者的日志称为可靠系统的重要组成部分，它要求与数据库本身一样重要。

  





### 







