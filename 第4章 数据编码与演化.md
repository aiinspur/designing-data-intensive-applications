# 第4章 数据编码与演化

[TOC]



## 数据编码格式

程序通常使用至少两种不同的数据表示形式：

1. 在内存中，数据保存在对象、结构体、列表、数组、哈希表和树等结构中。这些数据结构针对CPU的高效访问和操作进行了优化。

2. 将数据写入文档或通过网络发送时，必须将其编码为某种字自包含的字节序列。

   在上述两种表示之间需要进行类型的转化。从内存中的表示到字节序列的转化成为编码（或序列化），相反的过程称为解码。

## 语言特定的格式

许多特定的语言都内置支持将内存中的对象编码为字节序列。例如Java的java.io.Serializaable。第三方Java库：Kryo。

特定语言的编码、解码会存在一些问题，比如：

- 编码通常与特定语言绑定，而用另一种语言访问数据就比较困难
- 效率问题，Java内置序列化由于其糟糕的性能和臃肿的编码而广为诟病
- 安全问题
- 向前向后兼容问题

## JSON、XML与二进制变体

JSON、XML是可由不同变成语言编写和读取的标准化编码。XML经常被批评过于冗长和不必要的复杂。JSON受欢迎主要是由于它在WEB浏览器中内置支持以及相对于XML的简单性。CSV是另一种流行的语言无关的格式，尽管功能较弱。

JSON、XML、CSV都是文本格式。

### 二进制编码

对于TB级的数据集来说，数据格式的选择影响很大。

JSON不像XML那么冗长，但与二进制格式相比，仍旧占用大量空间。

### Thrift与Protocol Buffers

二者是基于相同原理的二进制编码库。

### Avro

Avro是另一种二进制编码格式

### JSON、XML等文本数据格式 VS 基于模式的二进制编码（Avro、Thrift、Protobuf等）

## 数据流模式

常见的进程间数据流动的方式：

- 通过数据库
- 通过服务调用
- 通过异步消息传递

### 基于数据库的数据流动

### 基于服务的数据流：REST和RPC

将大型应用程序按照功能区域分解为较小的服务，这样当一个服务需要另一个服务的某些功能或数据时，就会乡另一个服务发出请求。这种构建应用程序的方式传统上被称为面向服务的体系结构（SOA），**后来则更名为微服务体系结构**（microservices architecture）。

REST似乎是公共API的主流风格；RPC框架主要侧重于统一组织内多项服务之间的请求，通常发生在同一数据中心内。

#### 网络服务

有两种流行的Web服务方法：REST和SOAP，它们在设计理念方面几乎是截然相反的。

REST不是一种协议，而是一个基于HTTP原则的设计理念。根据REST原则所设计的API称RESTful。

SOAP是一种基于XML的协议，用于发出网络API请求。虽然它常用于HTTP，但其目的是独立于HTTP，并避免使用大多数HTTP功能。相反，它带有庞大而复杂的多种相关标准和新增的各种功能。

SOAP是一种特定的技术，而SOA是构建系统的一般方法。

#### 远程过程调用

基于Remote Procedure Call（RPC）的思想在20世纪70年代以来就一直存在。RPC起初看起来很方便，但这种方法在根本上是有缺陷的。网络请求与本地函数调用非常不同：

- 本地函数是可预测的；网络请求是不可预测的
- 本地函数调用要么返回一个结果，要么抛出一个异常或者永远不会返回（进入无限循环或者进程崩溃）；网络请求还有另一种可能-超时。
- 如果重试失败的网络请求，需要有幂等机制
- 每次调用本地函数，通常需要大致相同的时间；网络请求比函数调用要慢的多，其延迟也有很大的变化
- 调用本地函数时，可以高效的将引用传递给本地内存中的对象；当发出网络请求时，所有这些参数都需要被编码成可以通过网络发送的字节序列
- 客户端和服务端可以用不同的变成语言来实现，所以RPC框架必须将数据类型从一种语言转化成另一种语言。因为不是所有的语言都具有相同的类型，所以最终可能会丑陋，比如JavaScript的数字大于2的53次幂的问题。用单一语言编写的单个进程不存在次问题

#### RPC的发展方向

#### RPC的数据编码和演化

### 基于消息传递的数据流

#### 消息代理

#### Actor模型

Actor模型适用于对一致性需求不是很高且对性能需求较高的场景。



### 滚动升级

向后兼容性：新代码可以读取旧数据；

向前兼容性：旧代码可以读取新数据；







