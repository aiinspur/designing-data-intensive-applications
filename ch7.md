# 第7章 事务

[TOC]

# 术语

ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）

BASE：基本可用性（Basically Available）、软状态（Soft state）和最终一致性（Evental consistency）

# 什么是事务

事务将应用程序的多个读、写操作捆绑在一起称为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交），要么失败（中止或回滚）。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况，**应用层的错误处理就变得简单很多。**

事务是被认为创造出来的，**目的是简化应用层的变成模型。**

# 事务所提供的安全保证ACID

**原子性**所定义的特征：在出错时中止事务，并将部分完成的写入全部丢弃。

**一致性**只要是指数据库处于应用程序所期待的“预期状态”。原子性、隔离性和持久性是数据库自身的属性，而ACID中的一致性更多是应用层的属性。**应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库**。因此，字母C其实并不应该属于ACID。

**隔离性**：并发执行的多个事务相互隔离，不能交叉。例如，某个事务进行多次写入，则另一个事务观察到的是其全部完成（或者一个都没有完成）的结果，而不应该看到中间的部分结果。

**持久性**：保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的数据也不会消失。

# 事务的发展历史

1975年IBM推出第一个SQL数据库System R。几十年过去了，目前几乎所有的关系数据库和一些非关系数据库等系统（如MySQL、PostgreSQL、Oracle、SQL Server等）实现的事务于当年System R非常相似。

21世纪末，NoSQL数据库开始兴起。它们的目标是通过提供新的数据模型，以及内置的复制和分区等手段来改进传统的关系模型。然后事务却成了受害者：很多新一代的数据库完全放弃了事务支持，或者将其重新定义，即替换为比以前弱的多的保证。

# 事务的隔离级别

## 读-提交隔离

读-提交是最基本的事务隔离级别，它只提供一下两个保证：

1. 读数据库时，只能看到已经提交的数据（防止“脏读”）。
2. 写数据库时，只会覆盖已成功提交的数据（防止“脏写”）。

读-提交隔离级别非常流行。它是Oracle 11g，PostgreSQL，SQL Server 2012等的默认配置。

### 脏读

假定某个事务已经完成部分数据写入，但事务尚未提交（或中止），此时另一个事务是否可以看到尚未提交的数据呢？如果是的话，那就是**脏读**。

### 脏写

如果两个事务同时尝试更新相同的对象，会发生什么情况呢？我们无法预测写入的顺序，但是可以想象后写的操作会覆盖较早的写入。但是，如果先前的写入是尚未提交事务的一部分，是否还是被覆盖？如果是，那就是脏写。**在读-提交隔离级别下，防止脏写的通常方式是推迟第二个写请求，直到前面的事务完成提交（或中止）。**

### 如何防止脏写

**数据库通常采用行级锁来防止脏写。**给定时刻，只有一个事务可以拿到特定对象的锁，如果有另一个事务尝试更新同一个对象，则必须等待，直到前面的事务完成了提交（或中断）后，才能获得锁并继续。行级锁有出于读-提交模式的数据库自动完成的。

### 如何防止脏读

#### 方案一：采用行级锁

读锁的方式在实际中并不可行。因为运行时间较长的写事务会导致许多只读的事务等待太长时间，这会严重影响只读事务的响应延迟。

#### 方案二：MVCC 多版本并发控制

对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本。在事务提交之前，所以其它读操作都读取旧值；仅当写事务提交之后，才会读取到新值。

## 快照级别隔离

读-提交隔离级别不能解决读倾斜（不可重复读）问题。

**快照级别隔离是解决读倾斜的常见方法。**

