# 第7章 事务

[TOC]

# 术语

ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）

BASE：基本可用性（Basically Available）、软状态（Soft state）和最终一致性（Evental consistency）

# 什么是事务

事务将应用程序的多个读、写操作捆绑在一起称为一个逻辑操作单元。即事务中的所有读写是一个执行的整体，整个事务要么成功（提交），要么失败（中止或回滚）。如果失败，应用程序可以安全地重试。这样，由于不需要担心部分失败的情况，**应用层的错误处理就变得简单很多。**

事务是被认为创造出来的，**目的是简化应用层的变成模型。**

# 事务的作用

事务作为一个抽象层，使得应用程序可以忽略数据库内部一些复杂的并发问题，以及某些软、硬件故障，从而简化应用层的处理逻辑，大量的错误可以转化为简单的事务中止和应用层重试。

# 事务所提供的安全保证ACID

**原子性**所定义的特征：在出错时中止事务，并将部分完成的写入全部丢弃。

**一致性**只要是指数据库处于应用程序所期待的“预期状态”。原子性、隔离性和持久性是数据库自身的属性，而ACID中的一致性更多是应用层的属性。**应用程序可能借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库**。因此，字母C其实并不应该属于ACID。

**隔离性**：并发执行的多个事务相互隔离，不能交叉。例如，某个事务进行多次写入，则另一个事务观察到的是其全部完成（或者一个都没有完成）的结果，而不应该看到中间的部分结果。

**持久性**：保证一旦事务提交成功，即使存在硬件故障或数据库崩溃，事务所写入的数据也不会消失。

# 事务的发展历史

1975年IBM推出第一个SQL数据库System R。几十年过去了，目前几乎所有的关系数据库和一些非关系数据库等系统（如MySQL、PostgreSQL、Oracle、SQL Server等）实现的事务于当年System R非常相似。

21世纪末，NoSQL数据库开始兴起。它们的目标是通过提供新的数据模型，以及内置的复制和分区等手段来改进传统的关系模型。然后事务却成了受害者：很多新一代的数据库完全放弃了事务支持，或者将其重新定义，即替换为比以前弱的多的保证。

# 事务的隔离级别

## 读-提交隔离

读-提交是最基本的事务隔离级别，它只提供一下两个保证：

1. 读数据库时，只能看到已经提交的数据（防止“脏读”）。
2. 写数据库时，只会覆盖已成功提交的数据（防止“脏写”）。

读-提交隔离级别非常流行。它是Oracle 11g，PostgreSQL，SQL Server 2012等的默认配置。

### 脏读

假定某个事务已经完成部分数据写入，但事务尚未提交（或中止），此时另一个事务是否可以看到尚未提交的数据呢？如果是的话，那就是**脏读**。

### 脏写

如果两个事务同时尝试更新相同的对象，会发生什么情况呢？我们无法预测写入的顺序，但是可以想象后写的操作会覆盖较早的写入。但是，如果先前的写入是尚未提交事务的一部分，是否还是被覆盖？如果是，那就是脏写。**在读-提交隔离级别下，防止脏写的通常方式是推迟第二个写请求，直到前面的事务完成提交（或中止）。**

### 如何防止脏写

**数据库通常采用行级锁来防止脏写。**给定时刻，只有一个事务可以拿到特定对象的锁，如果有另一个事务尝试更新同一个对象，则必须等待，直到前面的事务完成了提交（或中断）后，才能获得锁并继续。行级锁有出于读-提交模式的数据库自动完成的。

### 如何防止脏读

#### 方案一：采用行级锁

读锁的方式在实际中并不可行。因为运行时间较长的写事务会导致许多只读的事务等待太长时间，这会严重影响只读事务的响应延迟。

#### 方案二：MVCC 多版本并发控制

对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本。在事务提交之前，所以其它读操作都读取旧值；仅当写事务提交之后，才会读取到新值。

## 快照级别隔离

读-提交隔离级别不能解决读倾斜（不可重复读）问题。

**快照级别隔离是解决读倾斜的常见方法。**

# 更新丢失问题（并发写事务冲突）

## 更新丢失问题的应用场景

读-提交和快照隔离级别主要是为了解决只读事务遇到并发写时可以看到什么。两个写事务并发还会带来其它一些问题，最著名的就是**更新丢失问题**。

更新丢失发生的的可能场景：应用程序从数据库读取某些值，根据应用逻辑作出修改，然后写回新值（read-modify-write过程）。当有两个事务在同样的数据对象上执行类型操作时，由于隔离性，第二个写操作并不包括第一个事务修改后的值，最终会导致第一个事务的修改值可能会丢失。还有其它不同的场景：

- 递增计数器，或更新账户余额。
- 对某个复杂对象的一部分内容执行修改，如对JSON文档中一个列表添加新的元素。
- 两个用户同时编辑wiki页面，且每个用户都尝试将整个页面发送到服务器。

## 更新丢失问题的解决方案

### 1、（数据库提供的）原子写操作

许多数据库提供了原子更新操作，如果支持的话，通常是最好的解决方案。

原子操作通常采用对读取对象加独占锁的方式来实现，这样在更新被提交之前不会有其它事务读取它。这种技术有时被称为游标稳定性。另一个方式是强制所有的原子操作都在单线程上执行。

### 2、（应用程序）显示加锁

### 3、（事务管理器）自动检测更新丢失

### 4、原子比较和设置

例如，为了防止两个用户同时更新同一个wiki页面，可以尝试下面的操作

update wiki_pages set content='new content' where id=1234 and content='old content'

###  5、冲突解决与复制

加锁和原子修改都有一个前提即只有一个最新的数据副本。 对于支持多副本的数据库，通常支持多个并发写，然后保留多个冲突版本（互称为兄弟），之后由应用层逻辑或者依靠特定的数据结构来解决、合并多个版本。

最后写入获胜（LWW）冲突解决方法容易造成数据丢失更新。

# 幻读

写倾斜都遵循如下类似的模式：

1. 首先输入一些匹配条件，即采用select查询所有满足条件的行（例如，至少有两名医生在值班，同一时刻房间没有被预定，一个用户的已退金额小于订单金额等）
2. 根据查询的结果，应用层代码来决定下一步的操作（有可能继续，或者报告错误并中止）
3. 如果应用程序决定继续，它将发起数据库写入（insert，update或者delete）并提交事务

上述步骤3中的写操作会改变步骤2作出决定的前提条件。**在一个事务中的写入改变了另一个事务查询结果的现象，称为幻读。**快照级别隔离可以避免只读查询时的幻读，但是对于读-写事务，它却无法解决写倾斜问题。

# 串行化

串行化是解决写倾斜和幻读的答案。

可串行化隔离通常被认为是最强的隔离级别。它保证几十事务可能会并行执行，但最终的结果与每次一个即串行执行结果相同。这意味着，如果事务在单独运行时表现正确，那么它们在并发运行时结果仍然正确。换句话说，数据库可以防止所有的可能的竞争条件。

## 串行化为什么没有广泛使用？

## 实现串行化的三种技术

### 1、严格按照串行顺序执行

VoltDB/H-Store、Redis和Datomic采用串行化方式执行事务。单线程执行有时可能比支持并发的系统效率更高，尤其是可以避免锁开销。但是，其吞吐上限是单个cpu核的吞吐量。为了充分利用单线程，相比于传统的形式，事务也需要作出相应调整。

如今，存储过程已使用通用编程语言编写，例如VoltDB使用Java或者Groovy，Redis使用Lua。

### 2、两阶（two-phase locking 2PL）段锁定

#### 2PL的定义

近三十年来，可以说数据库只有一种被广泛使用的串行化算法，就是两阶段加锁。

多个事务可以同事读取同一个对象，但只要出现任何写操作（修改或删除），则必须加锁以独占访问：

- 如果事务A已经读取了某个对象，此时事务B想要写入该对象，那么B必须等到A提交或中止才能继续。以确保B不会在事务A执行的过程中间去修改对象。
- 如果事务A已经修改了对象，此时事务B想要读取该对象，则B必须等到A提交或中止之后才能继续。对与2PL，不会出现读到旧值的情况。

2PL不仅在并发写操作之间互斥，读取也会和修改产生互斥。快照级别隔离的口号“读写互不干扰”非常准确的点明了它和两阶段加锁的关键区别。因为2PL提供了串行化，所以它可以防止所有的竞争条件，包括更新丢失和写倾斜。

#### 2PL的实现

目前，**2PL已经用于MySQL（InnoDB）和SQL Server中的“可串行化隔离”，以及DB2中的“可重复读隔离”。**

此时数据库的每个对象都有一个读写锁来隔离读写操作。即锁可以处于共享模式或独占模式。基本用法如下：

- 如果事务要读取对象，必须先以共享模式获得锁。可以有多个事务同时获得一个对象的共享锁，但是如果某个事务已经获得了对象的独占锁，则所有其它事务必须等待。
- 如果事务要修改对象，必须以独占模式获得锁。不允许多个事务同时持有该锁（包括独享或独占模式），换言之，如果对象上已被加锁，则修改事务必须等待。
- 如果事务首先读取对象，然后尝试写入对象，则需要将共享锁升级为独占锁。升级锁的流程等价于直接获得独占锁。
- 事务获得锁之后，一直持有锁直到事务结束（包括提交或中止）。这也是名字“两阶段”的由来，在第一阶段即事务执行之前要获得锁，第二阶段（即事务结束时）则释放锁。

出现死锁，数据库系统会自动检测事务之间死锁的情况，并强行中止其中的一个以打破僵局，**被中止的事务需要应用层来重试**（应用层如何感知事务被强行中止？）。

#### 2PL的性能

性能问题是两阶段加锁的主要缺点。

锁的获取和释放会造成开销；降低了事务的并发性。

谓词锁

索引区间锁

### 3、乐观并发控制技术

可串行化的快照隔离SSI。

如果冲突很多，则性能不佳，大量的事务必须中止。

如果事务之间的竞争不大，乐观并发控制会比悲观方式高效很多。

